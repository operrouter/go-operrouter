// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: proto/operrouter.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OperRouter_Ping_FullMethodName              = "/operrouter.v1.OperRouter/Ping"
	OperRouter_ValidateConfig_FullMethodName    = "/operrouter.v1.OperRouter/ValidateConfig"
	OperRouter_LoadConfig_FullMethodName        = "/operrouter.v1.OperRouter/LoadConfig"
	OperRouter_GetMetadata_FullMethodName       = "/operrouter.v1.OperRouter/GetMetadata"
	OperRouter_CreateDataSource_FullMethodName  = "/operrouter.v1.OperRouter/CreateDataSource"
	OperRouter_QueryDataSource_FullMethodName   = "/operrouter.v1.OperRouter/QueryDataSource"
	OperRouter_ExecuteDataSource_FullMethodName = "/operrouter.v1.OperRouter/ExecuteDataSource"
	OperRouter_InsertDataSource_FullMethodName  = "/operrouter.v1.OperRouter/InsertDataSource"
	OperRouter_PingDataSource_FullMethodName    = "/operrouter.v1.OperRouter/PingDataSource"
	OperRouter_CloseDataSource_FullMethodName   = "/operrouter.v1.OperRouter/CloseDataSource"
	OperRouter_CreateLLM_FullMethodName         = "/operrouter.v1.OperRouter/CreateLLM"
	OperRouter_GenerateLLM_FullMethodName       = "/operrouter.v1.OperRouter/GenerateLLM"
	OperRouter_ChatLLM_FullMethodName           = "/operrouter.v1.OperRouter/ChatLLM"
	OperRouter_EmbeddingLLM_FullMethodName      = "/operrouter.v1.OperRouter/EmbeddingLLM"
	OperRouter_StreamLLM_FullMethodName         = "/operrouter.v1.OperRouter/StreamLLM"
	OperRouter_PingLLM_FullMethodName           = "/operrouter.v1.OperRouter/PingLLM"
	OperRouter_CloseLLM_FullMethodName          = "/operrouter.v1.OperRouter/CloseLLM"
)

// OperRouterClient is the client API for OperRouter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Main service definition
type OperRouterClient interface {
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error)
	LoadConfig(ctx context.Context, in *LoadConfigRequest, opts ...grpc.CallOption) (*LoadConfigResponse, error)
	GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error)
	// DataSource operations
	CreateDataSource(ctx context.Context, in *CreateDataSourceRequest, opts ...grpc.CallOption) (*CreateDataSourceResponse, error)
	QueryDataSource(ctx context.Context, in *QueryDataSourceRequest, opts ...grpc.CallOption) (*QueryDataSourceResponse, error)
	ExecuteDataSource(ctx context.Context, in *ExecuteDataSourceRequest, opts ...grpc.CallOption) (*ExecuteDataSourceResponse, error)
	InsertDataSource(ctx context.Context, in *InsertDataSourceRequest, opts ...grpc.CallOption) (*InsertDataSourceResponse, error)
	PingDataSource(ctx context.Context, in *PingDataSourceRequest, opts ...grpc.CallOption) (*PingDataSourceResponse, error)
	CloseDataSource(ctx context.Context, in *CloseDataSourceRequest, opts ...grpc.CallOption) (*CloseDataSourceResponse, error)
	// LLM operations
	CreateLLM(ctx context.Context, in *CreateLLMRequest, opts ...grpc.CallOption) (*CreateLLMResponse, error)
	GenerateLLM(ctx context.Context, in *GenerateLLMRequest, opts ...grpc.CallOption) (*GenerateLLMResponse, error)
	ChatLLM(ctx context.Context, in *ChatLLMRequest, opts ...grpc.CallOption) (*ChatLLMResponse, error)
	EmbeddingLLM(ctx context.Context, in *EmbeddingLLMRequest, opts ...grpc.CallOption) (*EmbeddingLLMResponse, error)
	StreamLLM(ctx context.Context, in *StreamLLMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamLLMResponse], error)
	PingLLM(ctx context.Context, in *PingLLMRequest, opts ...grpc.CallOption) (*PingLLMResponse, error)
	CloseLLM(ctx context.Context, in *CloseLLMRequest, opts ...grpc.CallOption) (*CloseLLMResponse, error)
}

type operRouterClient struct {
	cc grpc.ClientConnInterface
}

func NewOperRouterClient(cc grpc.ClientConnInterface) OperRouterClient {
	return &operRouterClient{cc}
}

func (c *operRouterClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, OperRouter_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateConfigResponse)
	err := c.cc.Invoke(ctx, OperRouter_ValidateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) LoadConfig(ctx context.Context, in *LoadConfigRequest, opts ...grpc.CallOption) (*LoadConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadConfigResponse)
	err := c.cc.Invoke(ctx, OperRouter_LoadConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMetadataResponse)
	err := c.cc.Invoke(ctx, OperRouter_GetMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) CreateDataSource(ctx context.Context, in *CreateDataSourceRequest, opts ...grpc.CallOption) (*CreateDataSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDataSourceResponse)
	err := c.cc.Invoke(ctx, OperRouter_CreateDataSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) QueryDataSource(ctx context.Context, in *QueryDataSourceRequest, opts ...grpc.CallOption) (*QueryDataSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryDataSourceResponse)
	err := c.cc.Invoke(ctx, OperRouter_QueryDataSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) ExecuteDataSource(ctx context.Context, in *ExecuteDataSourceRequest, opts ...grpc.CallOption) (*ExecuteDataSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteDataSourceResponse)
	err := c.cc.Invoke(ctx, OperRouter_ExecuteDataSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) InsertDataSource(ctx context.Context, in *InsertDataSourceRequest, opts ...grpc.CallOption) (*InsertDataSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertDataSourceResponse)
	err := c.cc.Invoke(ctx, OperRouter_InsertDataSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) PingDataSource(ctx context.Context, in *PingDataSourceRequest, opts ...grpc.CallOption) (*PingDataSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingDataSourceResponse)
	err := c.cc.Invoke(ctx, OperRouter_PingDataSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) CloseDataSource(ctx context.Context, in *CloseDataSourceRequest, opts ...grpc.CallOption) (*CloseDataSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseDataSourceResponse)
	err := c.cc.Invoke(ctx, OperRouter_CloseDataSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) CreateLLM(ctx context.Context, in *CreateLLMRequest, opts ...grpc.CallOption) (*CreateLLMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLLMResponse)
	err := c.cc.Invoke(ctx, OperRouter_CreateLLM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) GenerateLLM(ctx context.Context, in *GenerateLLMRequest, opts ...grpc.CallOption) (*GenerateLLMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateLLMResponse)
	err := c.cc.Invoke(ctx, OperRouter_GenerateLLM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) ChatLLM(ctx context.Context, in *ChatLLMRequest, opts ...grpc.CallOption) (*ChatLLMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatLLMResponse)
	err := c.cc.Invoke(ctx, OperRouter_ChatLLM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) EmbeddingLLM(ctx context.Context, in *EmbeddingLLMRequest, opts ...grpc.CallOption) (*EmbeddingLLMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingLLMResponse)
	err := c.cc.Invoke(ctx, OperRouter_EmbeddingLLM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) StreamLLM(ctx context.Context, in *StreamLLMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamLLMResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &OperRouter_ServiceDesc.Streams[0], OperRouter_StreamLLM_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamLLMRequest, StreamLLMResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperRouter_StreamLLMClient = grpc.ServerStreamingClient[StreamLLMResponse]

func (c *operRouterClient) PingLLM(ctx context.Context, in *PingLLMRequest, opts ...grpc.CallOption) (*PingLLMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingLLMResponse)
	err := c.cc.Invoke(ctx, OperRouter_PingLLM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operRouterClient) CloseLLM(ctx context.Context, in *CloseLLMRequest, opts ...grpc.CallOption) (*CloseLLMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseLLMResponse)
	err := c.cc.Invoke(ctx, OperRouter_CloseLLM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperRouterServer is the server API for OperRouter service.
// All implementations must embed UnimplementedOperRouterServer
// for forward compatibility.
//
// Main service definition
type OperRouterServer interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	ValidateConfig(context.Context, *ValidateConfigRequest) (*ValidateConfigResponse, error)
	LoadConfig(context.Context, *LoadConfigRequest) (*LoadConfigResponse, error)
	GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataResponse, error)
	// DataSource operations
	CreateDataSource(context.Context, *CreateDataSourceRequest) (*CreateDataSourceResponse, error)
	QueryDataSource(context.Context, *QueryDataSourceRequest) (*QueryDataSourceResponse, error)
	ExecuteDataSource(context.Context, *ExecuteDataSourceRequest) (*ExecuteDataSourceResponse, error)
	InsertDataSource(context.Context, *InsertDataSourceRequest) (*InsertDataSourceResponse, error)
	PingDataSource(context.Context, *PingDataSourceRequest) (*PingDataSourceResponse, error)
	CloseDataSource(context.Context, *CloseDataSourceRequest) (*CloseDataSourceResponse, error)
	// LLM operations
	CreateLLM(context.Context, *CreateLLMRequest) (*CreateLLMResponse, error)
	GenerateLLM(context.Context, *GenerateLLMRequest) (*GenerateLLMResponse, error)
	ChatLLM(context.Context, *ChatLLMRequest) (*ChatLLMResponse, error)
	EmbeddingLLM(context.Context, *EmbeddingLLMRequest) (*EmbeddingLLMResponse, error)
	StreamLLM(*StreamLLMRequest, grpc.ServerStreamingServer[StreamLLMResponse]) error
	PingLLM(context.Context, *PingLLMRequest) (*PingLLMResponse, error)
	CloseLLM(context.Context, *CloseLLMRequest) (*CloseLLMResponse, error)
	mustEmbedUnimplementedOperRouterServer()
}

// UnimplementedOperRouterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOperRouterServer struct{}

func (UnimplementedOperRouterServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedOperRouterServer) ValidateConfig(context.Context, *ValidateConfigRequest) (*ValidateConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateConfig not implemented")
}
func (UnimplementedOperRouterServer) LoadConfig(context.Context, *LoadConfigRequest) (*LoadConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadConfig not implemented")
}
func (UnimplementedOperRouterServer) GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetadata not implemented")
}
func (UnimplementedOperRouterServer) CreateDataSource(context.Context, *CreateDataSourceRequest) (*CreateDataSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDataSource not implemented")
}
func (UnimplementedOperRouterServer) QueryDataSource(context.Context, *QueryDataSourceRequest) (*QueryDataSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDataSource not implemented")
}
func (UnimplementedOperRouterServer) ExecuteDataSource(context.Context, *ExecuteDataSourceRequest) (*ExecuteDataSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteDataSource not implemented")
}
func (UnimplementedOperRouterServer) InsertDataSource(context.Context, *InsertDataSourceRequest) (*InsertDataSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertDataSource not implemented")
}
func (UnimplementedOperRouterServer) PingDataSource(context.Context, *PingDataSourceRequest) (*PingDataSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingDataSource not implemented")
}
func (UnimplementedOperRouterServer) CloseDataSource(context.Context, *CloseDataSourceRequest) (*CloseDataSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseDataSource not implemented")
}
func (UnimplementedOperRouterServer) CreateLLM(context.Context, *CreateLLMRequest) (*CreateLLMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLLM not implemented")
}
func (UnimplementedOperRouterServer) GenerateLLM(context.Context, *GenerateLLMRequest) (*GenerateLLMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateLLM not implemented")
}
func (UnimplementedOperRouterServer) ChatLLM(context.Context, *ChatLLMRequest) (*ChatLLMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChatLLM not implemented")
}
func (UnimplementedOperRouterServer) EmbeddingLLM(context.Context, *EmbeddingLLMRequest) (*EmbeddingLLMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmbeddingLLM not implemented")
}
func (UnimplementedOperRouterServer) StreamLLM(*StreamLLMRequest, grpc.ServerStreamingServer[StreamLLMResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamLLM not implemented")
}
func (UnimplementedOperRouterServer) PingLLM(context.Context, *PingLLMRequest) (*PingLLMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingLLM not implemented")
}
func (UnimplementedOperRouterServer) CloseLLM(context.Context, *CloseLLMRequest) (*CloseLLMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseLLM not implemented")
}
func (UnimplementedOperRouterServer) mustEmbedUnimplementedOperRouterServer() {}
func (UnimplementedOperRouterServer) testEmbeddedByValue()                    {}

// UnsafeOperRouterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperRouterServer will
// result in compilation errors.
type UnsafeOperRouterServer interface {
	mustEmbedUnimplementedOperRouterServer()
}

func RegisterOperRouterServer(s grpc.ServiceRegistrar, srv OperRouterServer) {
	// If the following call pancis, it indicates UnimplementedOperRouterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OperRouter_ServiceDesc, srv)
}

func _OperRouter_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_ValidateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).ValidateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_ValidateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).ValidateConfig(ctx, req.(*ValidateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_LoadConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).LoadConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_LoadConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).LoadConfig(ctx, req.(*LoadConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_GetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).GetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_GetMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).GetMetadata(ctx, req.(*GetMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_CreateDataSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDataSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).CreateDataSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_CreateDataSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).CreateDataSource(ctx, req.(*CreateDataSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_QueryDataSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDataSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).QueryDataSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_QueryDataSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).QueryDataSource(ctx, req.(*QueryDataSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_ExecuteDataSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteDataSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).ExecuteDataSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_ExecuteDataSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).ExecuteDataSource(ctx, req.(*ExecuteDataSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_InsertDataSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertDataSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).InsertDataSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_InsertDataSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).InsertDataSource(ctx, req.(*InsertDataSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_PingDataSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingDataSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).PingDataSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_PingDataSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).PingDataSource(ctx, req.(*PingDataSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_CloseDataSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseDataSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).CloseDataSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_CloseDataSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).CloseDataSource(ctx, req.(*CloseDataSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_CreateLLM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLLMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).CreateLLM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_CreateLLM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).CreateLLM(ctx, req.(*CreateLLMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_GenerateLLM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateLLMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).GenerateLLM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_GenerateLLM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).GenerateLLM(ctx, req.(*GenerateLLMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_ChatLLM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatLLMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).ChatLLM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_ChatLLM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).ChatLLM(ctx, req.(*ChatLLMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_EmbeddingLLM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbeddingLLMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).EmbeddingLLM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_EmbeddingLLM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).EmbeddingLLM(ctx, req.(*EmbeddingLLMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_StreamLLM_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamLLMRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OperRouterServer).StreamLLM(m, &grpc.GenericServerStream[StreamLLMRequest, StreamLLMResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperRouter_StreamLLMServer = grpc.ServerStreamingServer[StreamLLMResponse]

func _OperRouter_PingLLM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingLLMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).PingLLM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_PingLLM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).PingLLM(ctx, req.(*PingLLMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperRouter_CloseLLM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseLLMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperRouterServer).CloseLLM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperRouter_CloseLLM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperRouterServer).CloseLLM(ctx, req.(*CloseLLMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OperRouter_ServiceDesc is the grpc.ServiceDesc for OperRouter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OperRouter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "operrouter.v1.OperRouter",
	HandlerType: (*OperRouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _OperRouter_Ping_Handler,
		},
		{
			MethodName: "ValidateConfig",
			Handler:    _OperRouter_ValidateConfig_Handler,
		},
		{
			MethodName: "LoadConfig",
			Handler:    _OperRouter_LoadConfig_Handler,
		},
		{
			MethodName: "GetMetadata",
			Handler:    _OperRouter_GetMetadata_Handler,
		},
		{
			MethodName: "CreateDataSource",
			Handler:    _OperRouter_CreateDataSource_Handler,
		},
		{
			MethodName: "QueryDataSource",
			Handler:    _OperRouter_QueryDataSource_Handler,
		},
		{
			MethodName: "ExecuteDataSource",
			Handler:    _OperRouter_ExecuteDataSource_Handler,
		},
		{
			MethodName: "InsertDataSource",
			Handler:    _OperRouter_InsertDataSource_Handler,
		},
		{
			MethodName: "PingDataSource",
			Handler:    _OperRouter_PingDataSource_Handler,
		},
		{
			MethodName: "CloseDataSource",
			Handler:    _OperRouter_CloseDataSource_Handler,
		},
		{
			MethodName: "CreateLLM",
			Handler:    _OperRouter_CreateLLM_Handler,
		},
		{
			MethodName: "GenerateLLM",
			Handler:    _OperRouter_GenerateLLM_Handler,
		},
		{
			MethodName: "ChatLLM",
			Handler:    _OperRouter_ChatLLM_Handler,
		},
		{
			MethodName: "EmbeddingLLM",
			Handler:    _OperRouter_EmbeddingLLM_Handler,
		},
		{
			MethodName: "PingLLM",
			Handler:    _OperRouter_PingLLM_Handler,
		},
		{
			MethodName: "CloseLLM",
			Handler:    _OperRouter_CloseLLM_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLLM",
			Handler:       _OperRouter_StreamLLM_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/operrouter.proto",
}
